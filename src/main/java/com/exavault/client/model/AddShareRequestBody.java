/*
 * ExaVault API
 * See our API reference documentation at https://www.exavault.com/developer/api-docs/
 *
 * OpenAPI spec version: 2.0
 * Contact: support@exavault.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.exavault.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.exavault.client.model.SharesRecipients;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.threeten.bp.OffsetDateTime;
/**
 * AddShareRequestBody
 */


public class AddShareRequestBody {
  /**
   * The type of share to create. See above for a description of each.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    SHARED_FOLDER("shared_folder"),
    RECEIVE("receive"),
    SEND("send");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("resources")
  private List<String> resources = null;

  /**
   * Gets or Sets accessMode
   */
  @JsonAdapter(AccessModeEnum.Adapter.class)
  public enum AccessModeEnum {
    UPLOAD("upload"),
    DOWNLOAD("download"),
    DELETE("delete"),
    MODIFY("modify");

    private String value;

    AccessModeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static AccessModeEnum fromValue(String text) {
      for (AccessModeEnum b : AccessModeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<AccessModeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final AccessModeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public AccessModeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return AccessModeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("accessMode")
  private List<AccessModeEnum> accessMode = new ArrayList<AccessModeEnum>();

  @SerializedName("embed")
  private Boolean embed = null;

  @SerializedName("recipients")
  private List<SharesRecipients> recipients = null;

  @SerializedName("expiration")
  private OffsetDateTime expiration = null;

  @SerializedName("hasNotification")
  private Boolean hasNotification = null;

  @SerializedName("isPublic")
  private Boolean isPublic = null;

  @SerializedName("messageBody")
  private String messageBody = null;

  @SerializedName("notificationEmails")
  private List<String> notificationEmails = null;

  @SerializedName("password")
  private String password = null;

  @SerializedName("requireEmail")
  private Boolean requireEmail = null;

  @SerializedName("messageSubject")
  private String messageSubject = null;

  @SerializedName("fileDropCreateFolders")
  private Boolean fileDropCreateFolders = null;

  @SerializedName("sendingLocalFiles")
  private Boolean sendingLocalFiles = null;

  public AddShareRequestBody type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * The type of share to create. See above for a description of each.
   * @return type
  **/
  @Schema(example = "shared_folder", required = true, description = "The type of share to create. See above for a description of each.")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public AddShareRequestBody name(String name) {
    this.name = name;
    return this;
  }

   /**
   * A name for the share. This will be visible on the page that recipients visit. 
   * @return name
  **/
  @Schema(example = "Shared Folder", required = true, description = "A name for the share. This will be visible on the page that recipients visit. ")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public AddShareRequestBody resources(List<String> resources) {
    this.resources = resources;
    return this;
  }

  public AddShareRequestBody addResourcesItem(String resourcesItem) {
    if (this.resources == null) {
      this.resources = new ArrayList<String>();
    }
    this.resources.add(resourcesItem);
    return this;
  }

   /**
   * Array of resources for this share. See details on [how to specify resources](#section/Identifying-Resources) above.  **shared_folder** and **receive** shares must have only one &#x60;resource&#x60;, which is a directory that does not have a current share attached.  **send** shares may have multiple &#x60;resource&#x60; parameters. You can also leave this parameter null if you are planning to upload files to the send. If you are planning to upload files to the send that are not yet in your account, you will also need to call the [POST /shares/complete-send/{id}](#operation/completeDirectSend) endpoint to finish the send operation. 
   * @return resources
  **/
  @Schema(example = "[\"/testfolder\"]", description = "Array of resources for this share. See details on [how to specify resources](#section/Identifying-Resources) above.  **shared_folder** and **receive** shares must have only one `resource`, which is a directory that does not have a current share attached.  **send** shares may have multiple `resource` parameters. You can also leave this parameter null if you are planning to upload files to the send. If you are planning to upload files to the send that are not yet in your account, you will also need to call the [POST /shares/complete-send/{id}](#operation/completeDirectSend) endpoint to finish the send operation. ")
  public List<String> getResources() {
    return resources;
  }

  public void setResources(List<String> resources) {
    this.resources = resources;
  }

  public AddShareRequestBody accessMode(List<AccessModeEnum> accessMode) {
    this.accessMode = accessMode;
    return this;
  }

  public AddShareRequestBody addAccessModeItem(AccessModeEnum accessModeItem) {
    this.accessMode.add(accessModeItem);
    return this;
  }

   /**
   * Array of permissions that describes what people can do when they visit the share. Valid options are &#x60;upload&#x60; &#x60;download&#x60; &#x60;modify&#x60; and &#x60;delete&#x60;  Not all permissions work with all shares - **receive** shares must always have the permission to **upload** and never provide a method for visitors to **download**.  If you are creating a share of type **send** and plan to upload files from your own computer before completing the send with [POST /shares/complete-send/{id}](#operation/completeDirectSend), use the access mode **upload**
   * @return accessMode
  **/
  @Schema(required = true, description = "Array of permissions that describes what people can do when they visit the share. Valid options are `upload` `download` `modify` and `delete`  Not all permissions work with all shares - **receive** shares must always have the permission to **upload** and never provide a method for visitors to **download**.  If you are creating a share of type **send** and plan to upload files from your own computer before completing the send with [POST /shares/complete-send/{id}](#operation/completeDirectSend), use the access mode **upload**")
  public List<AccessModeEnum> getAccessMode() {
    return accessMode;
  }

  public void setAccessMode(List<AccessModeEnum> accessMode) {
    this.accessMode = accessMode;
  }

  public AddShareRequestBody embed(Boolean embed) {
    this.embed = embed;
    return this;
  }

   /**
   * Whether this share can be embedded within a web page.
   * @return embed
  **/
  @Schema(example = "false", description = "Whether this share can be embedded within a web page.")
  public Boolean isEmbed() {
    return embed;
  }

  public void setEmbed(Boolean embed) {
    this.embed = embed;
  }

  public AddShareRequestBody recipients(List<SharesRecipients> recipients) {
    this.recipients = recipients;
    return this;
  }

  public AddShareRequestBody addRecipientsItem(SharesRecipients recipientsItem) {
    if (this.recipients == null) {
      this.recipients = new ArrayList<SharesRecipients>();
    }
    this.recipients.add(recipientsItem);
    return this;
  }

   /**
   * People you want to invite to the share. **Note**: unless you also set the &#x60;messageSubject&#x60; and &#x60;messageBody&#x60; for the new share, invitation emails will not be sent to these recipients.
   * @return recipients
  **/
  @Schema(description = "People you want to invite to the share. **Note**: unless you also set the `messageSubject` and `messageBody` for the new share, invitation emails will not be sent to these recipients.")
  public List<SharesRecipients> getRecipients() {
    return recipients;
  }

  public void setRecipients(List<SharesRecipients> recipients) {
    this.recipients = recipients;
  }

  public AddShareRequestBody expiration(OffsetDateTime expiration) {
    this.expiration = expiration;
    return this;
  }

   /**
   * Expiration date for the share. If someone attempts to use the share after this date, they will receive an error that the share is not available.
   * @return expiration
  **/
  @Schema(example = "2017-09-25T14:12:10Z", description = "Expiration date for the share. If someone attempts to use the share after this date, they will receive an error that the share is not available.")
  public OffsetDateTime getExpiration() {
    return expiration;
  }

  public void setExpiration(OffsetDateTime expiration) {
    this.expiration = expiration;
  }

  public AddShareRequestBody hasNotification(Boolean hasNotification) {
    this.hasNotification = hasNotification;
    return this;
  }

   /**
   * Whether delivery receipts should be sent.
   * @return hasNotification
  **/
  @Schema(example = "false", description = "Whether delivery receipts should be sent.")
  public Boolean isHasNotification() {
    return hasNotification;
  }

  public void setHasNotification(Boolean hasNotification) {
    this.hasNotification = hasNotification;
  }

  public AddShareRequestBody isPublic(Boolean isPublic) {
    this.isPublic = isPublic;
    return this;
  }

   /**
   * Whether someone can visit the share without following a personalized recipient link.
   * @return isPublic
  **/
  @Schema(example = "true", description = "Whether someone can visit the share without following a personalized recipient link.")
  public Boolean isIsPublic() {
    return isPublic;
  }

  public void setIsPublic(Boolean isPublic) {
    this.isPublic = isPublic;
  }

  public AddShareRequestBody messageBody(String messageBody) {
    this.messageBody = messageBody;
    return this;
  }

   /**
   * The message to be included in email invitations for your recipients. Ignored if you have not also provided &#x60;recipients&#x60; and &#x60;messageSubject&#x60;
   * @return messageBody
  **/
  @Schema(description = "The message to be included in email invitations for your recipients. Ignored if you have not also provided `recipients` and `messageSubject`")
  public String getMessageBody() {
    return messageBody;
  }

  public void setMessageBody(String messageBody) {
    this.messageBody = messageBody;
  }

  public AddShareRequestBody notificationEmails(List<String> notificationEmails) {
    this.notificationEmails = notificationEmails;
    return this;
  }

  public AddShareRequestBody addNotificationEmailsItem(String notificationEmailsItem) {
    if (this.notificationEmails == null) {
      this.notificationEmails = new ArrayList<String>();
    }
    this.notificationEmails.add(notificationEmailsItem);
    return this;
  }

   /**
   * Emails that will receive delivery receipts for this share. &#x60;hasNotification&#x60; must be **true** for delivery receipts will be sent.
   * @return notificationEmails
  **/
  @Schema(example = "[\"notify@example.com\",\"notify2@example.com\"]", description = "Emails that will receive delivery receipts for this share. `hasNotification` must be **true** for delivery receipts will be sent.")
  public List<String> getNotificationEmails() {
    return notificationEmails;
  }

  public void setNotificationEmails(List<String> notificationEmails) {
    this.notificationEmails = notificationEmails;
  }

  public AddShareRequestBody password(String password) {
    this.password = password;
    return this;
  }

   /**
   * Set a password for recipients to access the share. All recipients will use the same password.
   * @return password
  **/
  @Schema(description = "Set a password for recipients to access the share. All recipients will use the same password.")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public AddShareRequestBody requireEmail(Boolean requireEmail) {
    this.requireEmail = requireEmail;
    return this;
  }

   /**
   * True if recipients must provide their email to view the share.
   * @return requireEmail
  **/
  @Schema(example = "false", description = "True if recipients must provide their email to view the share.")
  public Boolean isRequireEmail() {
    return requireEmail;
  }

  public void setRequireEmail(Boolean requireEmail) {
    this.requireEmail = requireEmail;
  }

  public AddShareRequestBody messageSubject(String messageSubject) {
    this.messageSubject = messageSubject;
    return this;
  }

   /**
   * Subject to use on emails inviting recipients to the share. Ignored if you have not also provided &#x60;recipients&#x60; and a &#x60;messageBody&#x60;
   * @return messageSubject
  **/
  @Schema(example = "Invitation to a shared folder", description = "Subject to use on emails inviting recipients to the share. Ignored if you have not also provided `recipients` and a `messageBody`")
  public String getMessageSubject() {
    return messageSubject;
  }

  public void setMessageSubject(String messageSubject) {
    this.messageSubject = messageSubject;
  }

  public AddShareRequestBody fileDropCreateFolders(Boolean fileDropCreateFolders) {
    this.fileDropCreateFolders = fileDropCreateFolders;
    return this;
  }

   /**
   * Only used for **receive** shares. If true, uploads will be automatically placed into sub-folders of the folder, named after the chosen field on your form. 
   * @return fileDropCreateFolders
  **/
  @Schema(example = "false", description = "Only used for **receive** shares. If true, uploads will be automatically placed into sub-folders of the folder, named after the chosen field on your form. ")
  public Boolean isFileDropCreateFolders() {
    return fileDropCreateFolders;
  }

  public void setFileDropCreateFolders(Boolean fileDropCreateFolders) {
    this.fileDropCreateFolders = fileDropCreateFolders;
  }

  public AddShareRequestBody sendingLocalFiles(Boolean sendingLocalFiles) {
    this.sendingLocalFiles = sendingLocalFiles;
    return this;
  }

   /**
   * Use this only for **send** shares. Flag to indicate that you are going to upload additional files from your computer to the share. If this is **true**, you will also need to use the [POST /shares/complete-send/{id}](#operation/completeDirectSend) call to finish setting up your share after the files are uploaded.
   * @return sendingLocalFiles
  **/
  @Schema(description = "Use this only for **send** shares. Flag to indicate that you are going to upload additional files from your computer to the share. If this is **true**, you will also need to use the [POST /shares/complete-send/{id}](#operation/completeDirectSend) call to finish setting up your share after the files are uploaded.")
  public Boolean isSendingLocalFiles() {
    return sendingLocalFiles;
  }

  public void setSendingLocalFiles(Boolean sendingLocalFiles) {
    this.sendingLocalFiles = sendingLocalFiles;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AddShareRequestBody addShareRequestBody = (AddShareRequestBody) o;
    return Objects.equals(this.type, addShareRequestBody.type) &&
        Objects.equals(this.name, addShareRequestBody.name) &&
        Objects.equals(this.resources, addShareRequestBody.resources) &&
        Objects.equals(this.accessMode, addShareRequestBody.accessMode) &&
        Objects.equals(this.embed, addShareRequestBody.embed) &&
        Objects.equals(this.recipients, addShareRequestBody.recipients) &&
        Objects.equals(this.expiration, addShareRequestBody.expiration) &&
        Objects.equals(this.hasNotification, addShareRequestBody.hasNotification) &&
        Objects.equals(this.isPublic, addShareRequestBody.isPublic) &&
        Objects.equals(this.messageBody, addShareRequestBody.messageBody) &&
        Objects.equals(this.notificationEmails, addShareRequestBody.notificationEmails) &&
        Objects.equals(this.password, addShareRequestBody.password) &&
        Objects.equals(this.requireEmail, addShareRequestBody.requireEmail) &&
        Objects.equals(this.messageSubject, addShareRequestBody.messageSubject) &&
        Objects.equals(this.fileDropCreateFolders, addShareRequestBody.fileDropCreateFolders) &&
        Objects.equals(this.sendingLocalFiles, addShareRequestBody.sendingLocalFiles);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, name, resources, accessMode, embed, recipients, expiration, hasNotification, isPublic, messageBody, notificationEmails, password, requireEmail, messageSubject, fileDropCreateFolders, sendingLocalFiles);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AddShareRequestBody {\n");
    
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("    accessMode: ").append(toIndentedString(accessMode)).append("\n");
    sb.append("    embed: ").append(toIndentedString(embed)).append("\n");
    sb.append("    recipients: ").append(toIndentedString(recipients)).append("\n");
    sb.append("    expiration: ").append(toIndentedString(expiration)).append("\n");
    sb.append("    hasNotification: ").append(toIndentedString(hasNotification)).append("\n");
    sb.append("    isPublic: ").append(toIndentedString(isPublic)).append("\n");
    sb.append("    messageBody: ").append(toIndentedString(messageBody)).append("\n");
    sb.append("    notificationEmails: ").append(toIndentedString(notificationEmails)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    requireEmail: ").append(toIndentedString(requireEmail)).append("\n");
    sb.append("    messageSubject: ").append(toIndentedString(messageSubject)).append("\n");
    sb.append("    fileDropCreateFolders: ").append(toIndentedString(fileDropCreateFolders)).append("\n");
    sb.append("    sendingLocalFiles: ").append(toIndentedString(sendingLocalFiles)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
