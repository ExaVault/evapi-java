/*
 * ExaVault API
 * See our API reference documentation at https://www.exavault.com/developer/api-docs/
 *
 * OpenAPI spec version: 2.0
 * Contact: support@exavault.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.exavault.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.exavault.client.model.SharesRecipients;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.threeten.bp.OffsetDateTime;
/**
 * Body16
 */


public class Body16 {
  /**
   * The type of share to create. See above for a description of each.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    SHARED_FOLDER("shared_folder"),
    RECEIVE("receive"),
    SEND("send");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("resources")
  private List<String> resources = null;

  @SerializedName("accessMode")
  private List<String> accessMode = new ArrayList<String>();

  @SerializedName("embed")
  private Boolean embed = null;

  @SerializedName("recipients")
  private List<SharesRecipients> recipients = null;

  @SerializedName("expiration")
  private OffsetDateTime expiration = null;

  @SerializedName("hasNotification")
  private Boolean hasNotification = null;

  @SerializedName("isPublic")
  private Boolean isPublic = null;

  @SerializedName("message")
  private String message = null;

  @SerializedName("notificationEmails")
  private List<String> notificationEmails = null;

  @SerializedName("password")
  private String password = null;

  @SerializedName("requireEmail")
  private Boolean requireEmail = null;

  @SerializedName("subject")
  private String subject = null;

  @SerializedName("fileDropCreateFolders")
  private Boolean fileDropCreateFolders = null;

  @SerializedName("sendingLocalFiles")
  private Boolean sendingLocalFiles = null;

  public Body16 type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * The type of share to create. See above for a description of each.
   * @return type
  **/
  @Schema(example = "shared_folder", required = true, description = "The type of share to create. See above for a description of each.")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public Body16 name(String name) {
    this.name = name;
    return this;
  }

   /**
   * A name for the share. This will be visible on the page that recipients visit. 
   * @return name
  **/
  @Schema(example = "Shared Folder", required = true, description = "A name for the share. This will be visible on the page that recipients visit. ")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public Body16 resources(List<String> resources) {
    this.resources = resources;
    return this;
  }

  public Body16 addResourcesItem(String resourcesItem) {
    if (this.resources == null) {
      this.resources = new ArrayList<String>();
    }
    this.resources.add(resourcesItem);
    return this;
  }

   /**
   * Array of resources for this share. See details on [how to specify resources](#section/Identifying-Resources) above.  **shared_folder** and **receive** shares must have only one &#x60;resource&#x60;, which is a directory that does not have a current share attached.  **send** shares may have multiple &#x60;resource&#x60; parameters. You can also leave this parameter null if you are planning to upload files to the send. If you are planning to upload files to the send that are not yet in your account, you will also need to call the [POST /shares/complete-send/{id}](#operation/completeDirectSend) endpoint to finish the send operation. 
   * @return resources
  **/
  @Schema(example = "[\"/testfolder\"]", description = "Array of resources for this share. See details on [how to specify resources](#section/Identifying-Resources) above.  **shared_folder** and **receive** shares must have only one `resource`, which is a directory that does not have a current share attached.  **send** shares may have multiple `resource` parameters. You can also leave this parameter null if you are planning to upload files to the send. If you are planning to upload files to the send that are not yet in your account, you will also need to call the [POST /shares/complete-send/{id}](#operation/completeDirectSend) endpoint to finish the send operation. ")
  public List<String> getResources() {
    return resources;
  }

  public void setResources(List<String> resources) {
    this.resources = resources;
  }

  public Body16 accessMode(List<String> accessMode) {
    this.accessMode = accessMode;
    return this;
  }

  public Body16 addAccessModeItem(String accessModeItem) {
    this.accessMode.add(accessModeItem);
    return this;
  }

   /**
   * Array of permissions that describes what people can do when they visit the share. Valid options are &#x60;upload&#x60; &#x60;download&#x60; &#x60;modify&#x60; and &#x60;delete&#x60;  Not all permissions work with all shares - **receive** shares must always have the permission to **upload** and never provide a method for visitors to **download**.  If you are creating a share of type **send** and plan to upload files from your own computer before completing the send with [POST /shares/complete-send/{id}](#operation/completeDirectSend), use the access mode **upload**
   * @return accessMode
  **/
  @Schema(required = true, description = "Array of permissions that describes what people can do when they visit the share. Valid options are `upload` `download` `modify` and `delete`  Not all permissions work with all shares - **receive** shares must always have the permission to **upload** and never provide a method for visitors to **download**.  If you are creating a share of type **send** and plan to upload files from your own computer before completing the send with [POST /shares/complete-send/{id}](#operation/completeDirectSend), use the access mode **upload**")
  public List<String> getAccessMode() {
    return accessMode;
  }

  public void setAccessMode(List<String> accessMode) {
    this.accessMode = accessMode;
  }

  public Body16 embed(Boolean embed) {
    this.embed = embed;
    return this;
  }

   /**
   * Whether this share can be embedded within a web page.
   * @return embed
  **/
  @Schema(example = "false", description = "Whether this share can be embedded within a web page.")
  public Boolean isEmbed() {
    return embed;
  }

  public void setEmbed(Boolean embed) {
    this.embed = embed;
  }

  public Body16 recipients(List<SharesRecipients> recipients) {
    this.recipients = recipients;
    return this;
  }

  public Body16 addRecipientsItem(SharesRecipients recipientsItem) {
    if (this.recipients == null) {
      this.recipients = new ArrayList<SharesRecipients>();
    }
    this.recipients.add(recipientsItem);
    return this;
  }

   /**
   * People you want to invite to the share. **Note**: unless you also set the &#x60;subject&#x60; and &#x60;message&#x60; for the new share, invitation emails will not be sent to these recipients.
   * @return recipients
  **/
  @Schema(description = "People you want to invite to the share. **Note**: unless you also set the `subject` and `message` for the new share, invitation emails will not be sent to these recipients.")
  public List<SharesRecipients> getRecipients() {
    return recipients;
  }

  public void setRecipients(List<SharesRecipients> recipients) {
    this.recipients = recipients;
  }

  public Body16 expiration(OffsetDateTime expiration) {
    this.expiration = expiration;
    return this;
  }

   /**
   * Expiration date for the share. If someone attempts to use the share after this date, they will receive an error that the share is not available.
   * @return expiration
  **/
  @Schema(example = "2017-09-25T14:12:10Z", description = "Expiration date for the share. If someone attempts to use the share after this date, they will receive an error that the share is not available.")
  public OffsetDateTime getExpiration() {
    return expiration;
  }

  public void setExpiration(OffsetDateTime expiration) {
    this.expiration = expiration;
  }

  public Body16 hasNotification(Boolean hasNotification) {
    this.hasNotification = hasNotification;
    return this;
  }

   /**
   * Whether delivery receipts should be sent.
   * @return hasNotification
  **/
  @Schema(example = "false", description = "Whether delivery receipts should be sent.")
  public Boolean isHasNotification() {
    return hasNotification;
  }

  public void setHasNotification(Boolean hasNotification) {
    this.hasNotification = hasNotification;
  }

  public Body16 isPublic(Boolean isPublic) {
    this.isPublic = isPublic;
    return this;
  }

   /**
   * Whether someone can visit the share without following a personalized recipient link.
   * @return isPublic
  **/
  @Schema(example = "true", description = "Whether someone can visit the share without following a personalized recipient link.")
  public Boolean isIsPublic() {
    return isPublic;
  }

  public void setIsPublic(Boolean isPublic) {
    this.isPublic = isPublic;
  }

  public Body16 message(String message) {
    this.message = message;
    return this;
  }

   /**
   * The message to be included in email invitations for your recipients. Ignored if you have not also provided &#x60;recipients&#x60; and &#x60;subject&#x60;
   * @return message
  **/
  @Schema(description = "The message to be included in email invitations for your recipients. Ignored if you have not also provided `recipients` and `subject`")
  public String getMessage() {
    return message;
  }

  public void setMessage(String message) {
    this.message = message;
  }

  public Body16 notificationEmails(List<String> notificationEmails) {
    this.notificationEmails = notificationEmails;
    return this;
  }

  public Body16 addNotificationEmailsItem(String notificationEmailsItem) {
    if (this.notificationEmails == null) {
      this.notificationEmails = new ArrayList<String>();
    }
    this.notificationEmails.add(notificationEmailsItem);
    return this;
  }

   /**
   * Emails that will receive delivery receipts for this share. &#x60;hasNotification&#x60; must be **true** for delivery receipts will be sent.
   * @return notificationEmails
  **/
  @Schema(example = "[\"notify@example.com\",\"notify2@example.com\"]", description = "Emails that will receive delivery receipts for this share. `hasNotification` must be **true** for delivery receipts will be sent.")
  public List<String> getNotificationEmails() {
    return notificationEmails;
  }

  public void setNotificationEmails(List<String> notificationEmails) {
    this.notificationEmails = notificationEmails;
  }

  public Body16 password(String password) {
    this.password = password;
    return this;
  }

   /**
   * Set a password for recipients to access the share. All recipients will use the same password.
   * @return password
  **/
  @Schema(description = "Set a password for recipients to access the share. All recipients will use the same password.")
  public String getPassword() {
    return password;
  }

  public void setPassword(String password) {
    this.password = password;
  }

  public Body16 requireEmail(Boolean requireEmail) {
    this.requireEmail = requireEmail;
    return this;
  }

   /**
   * True if recipients must provide their email to view the share.
   * @return requireEmail
  **/
  @Schema(example = "false", description = "True if recipients must provide their email to view the share.")
  public Boolean isRequireEmail() {
    return requireEmail;
  }

  public void setRequireEmail(Boolean requireEmail) {
    this.requireEmail = requireEmail;
  }

  public Body16 subject(String subject) {
    this.subject = subject;
    return this;
  }

   /**
   * Subject to use on emails inviting recipients to the share. Ignored if you have not also provided &#x60;recipients&#x60; and a &#x60;message&#x60;
   * @return subject
  **/
  @Schema(example = "Invitation to a shared folder", description = "Subject to use on emails inviting recipients to the share. Ignored if you have not also provided `recipients` and a `message`")
  public String getSubject() {
    return subject;
  }

  public void setSubject(String subject) {
    this.subject = subject;
  }

  public Body16 fileDropCreateFolders(Boolean fileDropCreateFolders) {
    this.fileDropCreateFolders = fileDropCreateFolders;
    return this;
  }

   /**
   * Only used for **receive** shares. If true, uploads will be automatically placed into sub-folders of the folder, named after the chosen field on your form. 
   * @return fileDropCreateFolders
  **/
  @Schema(example = "false", description = "Only used for **receive** shares. If true, uploads will be automatically placed into sub-folders of the folder, named after the chosen field on your form. ")
  public Boolean isFileDropCreateFolders() {
    return fileDropCreateFolders;
  }

  public void setFileDropCreateFolders(Boolean fileDropCreateFolders) {
    this.fileDropCreateFolders = fileDropCreateFolders;
  }

  public Body16 sendingLocalFiles(Boolean sendingLocalFiles) {
    this.sendingLocalFiles = sendingLocalFiles;
    return this;
  }

   /**
   * Use this only for **send** shares. Flag to indicate that you are going to upload additional files from your computer to the share. If this is **true**, you will also need to use the [POST /shares/complete-send/{id}](#operation/completeDirectSend) call to finish setting up your share after the files are uploaded.
   * @return sendingLocalFiles
  **/
  @Schema(description = "Use this only for **send** shares. Flag to indicate that you are going to upload additional files from your computer to the share. If this is **true**, you will also need to use the [POST /shares/complete-send/{id}](#operation/completeDirectSend) call to finish setting up your share after the files are uploaded.")
  public Boolean isSendingLocalFiles() {
    return sendingLocalFiles;
  }

  public void setSendingLocalFiles(Boolean sendingLocalFiles) {
    this.sendingLocalFiles = sendingLocalFiles;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Body16 body16 = (Body16) o;
    return Objects.equals(this.type, body16.type) &&
        Objects.equals(this.name, body16.name) &&
        Objects.equals(this.resources, body16.resources) &&
        Objects.equals(this.accessMode, body16.accessMode) &&
        Objects.equals(this.embed, body16.embed) &&
        Objects.equals(this.recipients, body16.recipients) &&
        Objects.equals(this.expiration, body16.expiration) &&
        Objects.equals(this.hasNotification, body16.hasNotification) &&
        Objects.equals(this.isPublic, body16.isPublic) &&
        Objects.equals(this.message, body16.message) &&
        Objects.equals(this.notificationEmails, body16.notificationEmails) &&
        Objects.equals(this.password, body16.password) &&
        Objects.equals(this.requireEmail, body16.requireEmail) &&
        Objects.equals(this.subject, body16.subject) &&
        Objects.equals(this.fileDropCreateFolders, body16.fileDropCreateFolders) &&
        Objects.equals(this.sendingLocalFiles, body16.sendingLocalFiles);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, name, resources, accessMode, embed, recipients, expiration, hasNotification, isPublic, message, notificationEmails, password, requireEmail, subject, fileDropCreateFolders, sendingLocalFiles);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Body16 {\n");
    
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    resources: ").append(toIndentedString(resources)).append("\n");
    sb.append("    accessMode: ").append(toIndentedString(accessMode)).append("\n");
    sb.append("    embed: ").append(toIndentedString(embed)).append("\n");
    sb.append("    recipients: ").append(toIndentedString(recipients)).append("\n");
    sb.append("    expiration: ").append(toIndentedString(expiration)).append("\n");
    sb.append("    hasNotification: ").append(toIndentedString(hasNotification)).append("\n");
    sb.append("    isPublic: ").append(toIndentedString(isPublic)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    notificationEmails: ").append(toIndentedString(notificationEmails)).append("\n");
    sb.append("    password: ").append(toIndentedString(password)).append("\n");
    sb.append("    requireEmail: ").append(toIndentedString(requireEmail)).append("\n");
    sb.append("    subject: ").append(toIndentedString(subject)).append("\n");
    sb.append("    fileDropCreateFolders: ").append(toIndentedString(fileDropCreateFolders)).append("\n");
    sb.append("    sendingLocalFiles: ").append(toIndentedString(sendingLocalFiles)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
